СКАНЕР ШАРЫ
===========
получает на stdin по строкам:
 * айпи адрес (в числовой или точечной форме или fqdn имя хоста), возможно с указанием порта через ":"
 * имя шары, на которую нужно зайти,
 * имя пользователя или пустая строка, если заходить анонимно
 * пароль для входа на шару
 * рабочая группа для указания удаленному компьютеру
 * собственное имя для представления удаленной стороне
 * таймаут для операции соединения
 * максимальная глубина рекурсии

сканер соединяется с шарой, опрашивает все дерево каталогов рекурсивно и выводит на stdout данные в таком формате:
один файл - набор полей. все поля разделены по строкам. разделителем файлов служит пустая строка.
 * полный путь к файлу от корня запрошенной шары, включая начальный слеш
 * 0 или 1 - признак способности на рекурсивный спуск (директория)
 * размер файла в байтах
 * time_t запись времени создания файла
 * time_t запись времеин модификации файла

СКАНЕР ХОСТА
===================================
получает на stdin:
 * айпи адрес (в числовой или точечной форме или fqdn имя хоста), возможно с указанием порта через ":"
 * ресурс для пробы, или пусто, если нужно просканировать все ресурсы
 * имя пользователя для входа или пусто для гостевого
 * пароль для входа по имени
 * рабочая группа для указания удаленному компьютеру
 * собственное имя для представления удаленной стороне
 * таймаут для операции соединения

сканер соединяется с хостом, получает список имеющихся на нем ресурсов. выводит их на stdout.
формат вывода: одно поле на строчку. записи разделяются пустой строкой. поля:
 * имя шары, включая начальный слеш



ЦЕНТРАЛ
=======
соединяется с базой. читает список блоков адресов. 
сканер перебирает все адреса, исключая уже пройденные по ключу <ip,protocol,port,share,username>.

для protocol=smb
если имя шары не указано - читает список шар и перебирает их как если бы они и были указаны
в свойствах блоке. таким образом, сканинг может отброситься дважды: по уже просканированному айпи с пустой
шарой, и затем по конкретной шаре.

для protocol=ftp:
шара игнорируется.

для protocol=http:
шара игнорируется


выводит на stdout по одной строчке на поле. записи разделяются пустой строкой.
если на ресурс зайти нельзя, он не выводится. строки:
 * айпи адрес компьютера в dot-форме
 * протокол ресурса (smb, ftp, htpp...)
 * порт куда коннектиться или 0, если по дефолту для протокола
 * найденная шара, или пусто, если не нетбиос
 * имя пользователя, или пусто, если использовлся гостевая запись
 * пароль доступа или пусто
 * fqdn имя компа или пусто
 * netbios имя компа или пусто
 * netbios рабочая группа или пусто
 далее все до первой пустой строки все игнорируется. зарезервировано для будущих полей.


для получения списка ресурсов для каждого <protocol=smb,ip,share> вызывается сканер шар.
все, что выводит сканер, централ ловит и забрасывает в базу найденных хостов и ресурсов.

после сканирования всех блоков (или после каждого блока? или после каждого ресурса? или опцией?)
запускает для каждого найденного ресурса сканер файлов. и все найденные файлы по мере обнаружения
закидывает в базу (чтобы не хранить все в оперативной памяти).

имеет рассчет на различные типы сканов: самба ресурсы, фтп ресурсы, хттп ресурсы.
единственный модуль, имеющий соединение с БД.
единственный модуль, создающий подпроцессы.



















МЕНЕДЖЕР СКАНЕРОВ
=================
Специальная программа scanner-thread запускается центральным менеджером,
она принимает на stdin параметры соединения к базе, идентификаторы состояний
(процесс ид и время старта родителя), параметры запроса на сканирование (протокол, адреса...).
На основе этих данных выбирает нужный типа сканера и вызывает его с перехватом его вывода.
Все получаемые данные этот процесс закидывает в базу, обновляя при этом таблицу состояния.
После завершения сканера нужного протокола, менеджер сканеров снова принимает со stdin новые
данные, и снова вызывает нужный сканер.

При этом на каждый такой менеджер формируется собственное соединеине к базе данных. Следует
продумать систему изоляции запросов от менеджеров друг от друга, чтобы не вызывались конфликты.
Делать это все через мьютексы и одно-единственное соединение не имеет смысла, так как в случае
запуска нескольких сканеров все равно возникает множественность подключений и параллельность
запросов.

На stdout менеджер не выводит ничего.

Когда менеджер принимает с stdin конец файла (то есть закрытие пайпа со стороны централа),
он закрывает базу данных и выходит, считая что свое отслужил. Таблица состояния при этом
не очищается.

ЦЕНТРАЛЬНЫЙ МЕНЕДЖЕР
====================
Запускается в единственном экземпляре (по задумке). Множественные экземпляры напрасно нагрузят
процессор и сеть, но не должны вызывать друг у друга конфликтов. Можно организовать эксклюзивный
запуск через формирование и проверку pid-файла.

Его задача - запустить нужное количество менеджеров сканеров, и всегда поддерживать это количество.










